## MSA 전환에 따른 트랜잭션 관리 한계 및 해결 방안

## 개요

---

- 서비스의 규모가 확장되어 MSA의 형태로 각 도메인별로 배포단위를 분리해야한다면 그 분리에 따른 트랜잭션 처리의 한계와 해결 방안에 대해 정리한다.

## 트랜잭션의 기본 개념

---

### 트랜잭션이란?

- 데이터베이스 작업의 **논리적 단위**이다.
- **ACID** 특성을 준수해야한다.
    - **Atomicity** (원자성): 트랜잭션 내의 모든 작업이 성공하거나 모두 실패해야 한다.
    - **Consistency** (일관성): 트랜잭션이 완료된 후 데이터는 일관된 상태를 유지해야 한다.
    - **Isolation** (격리성): 트랜잭션은 다른 트랜잭션으로부터 영향을 받지 않아야 한다.
    - **Durability** (지속성): 트랜잭션이 완료되면 그 결과는 영구적으로 저장된다.
- 모놀리식 아키텍처에서의 트랜잭션
    
    ```mermaid
    graph LR
        A[트랜잭션 시작] --> B[DB1 작업]
        B --> C[DB2 작업]
        C --> D{성공?}
        D -->|Yes| E[Commit]
        D -->|No| F[Rollback]
    ```
    
    - 모놀리식 아키텍처에서의 트랜잭션은 모든 작업이 하나의 트랜잭션 안에서 이루어져, 성공 여부에 따라 커밋 혹은 롤백이 수행된다.

## E-commerce 주요 기능

---

- 현재 서비스 아키텍처 : 모놀리식 아키텍처
- 트랜잭션 범위 분석
    - **결제 생성**
        
        ```tsx
        결제_생성_TX () {
        	주문_조회();
        	결제_생성();
        	사용자_포인트_차감();
        	포인트_사용_내역_생성();
        	결제_상태_업데이트();
        	주문서_상태_업데이트();
        	결제_정보_조회();
        	
        	**데이터_플랫폼_전송();**
        }
        ```
        
        - 주문 조회, 결제 생성, 포인트 사용, **데이터 플랫폼 전송** 등의 로직이 하나의 트랜잭션 안에서 수행되고 있다.
        - 문제점
            - 하나의 트랜잭션 안에 많은 작업이 포함되어 있기에 타임아웃이 발생할 수 있다.
            - 데이터 플랫폼 전송을 제외한 로직은 정상 동작하였지만, 데이터 플랫폼 전송 실패시 해당 트랜잭션이 실패할 수 있다.
            - 데이터 플랫폼 전송이 성공하여 데이터 플랫폼에 데이터가 정상적으로 적재된 상황에 어떤 원인으로 인해 타임아웃이 발생하게 된다면 해당 트랜잭션이 실패하여 데이터 정합성 문제가 발생할 수 있다.
        - 해결 방안
            
            ```tsx
            // 결제 facade
            await 결제_생성_TX () {
            	주문_조회();
            	결제_생성();
            	사용자_포인트_차감();
            	포인트_사용_내역_생성();
            	결제_상태_업데이트();
            	주문서_상태_업데이트();
            	결제_정보_조회();
            }
            
            **결제_생성_완료_이벤트_발행();** // 이벤트 버스 사용
            ****
            
            // 이벤트 핸들러
            @EventsHandler(CompleteCreatePaymentEvent)
            export class CompleteCreatePaymentHandler implements IEventHandler<CompleteCreatePaymentEvent> {
                async handle(event: CompleteCreatePaymentEvent) {
                    const fakeDataPlatform = new FakeDataPlatform();
                    fakeDataPlatform.send(); // 데이터 플랫폼 전송
                }
            }
            ```
            
            - 위와 같이 eventBus를 사용하여 결제 생성 트랜잭션이 완료된 후에 결제 생성 완료 이벤트를 발행하여, 이벤트 핸들러에서 비동기적으로 데이터 플랫폼 전송을 처리해줄 수 있다.
    - 주문 생성
        
        ```tsx
        주문_생성_TX (){
        	사용자_조회();
        	상품_조회();
        	상품_재고_감소();
        	유저_쿠폰_조회();
        	쿠폰_상태_변경_및_가격_계산();
        	주문_생성();
        	주문_디테일_생성();
        }
        
        사용자_조회_TX () {
        }
        ```
        
        - 사용자 조회, 상품 조회, 상품 재고 감소, 쿠폰 적용 및 가격 계산 등의 로직이 하나의 트랜잭션 내에서 수행된다.
        - 문제점
            - 모든 작업이 하나의 트랜잭션 내에서 수행되기 때문에, 트랜잭션의 수행 시간이 길다.

## 서비스 분리 설계

---

### 서비스 분리 및 기능

- **Coupon** : 쿠폰 생성, 사용, 조회
- **History** : 모든 주요 활동에 대한 기록 관리
- **Product** : 상품 정보 관리, 재고 관리
- **Order** : 주문 생성, 상태 관리, 주문 내역 관리
- **Payment** : 결제 생성, 상태 관리
- **User** : 사용자 정보 및 포인트 관리

### 서비스 분리 설계

- **결제 생성**
    
    ```tsx
    주문_처리_TX () {
    	주문_조회();
    	주문서_상태_업데이트();
    }
    
    결제_처리_TX () {
    	결제_생성();
    	결제_상태_업데이트();
    	결제_정보_조회();
    }
    
    유저_포인트_차감_TX () {
    	사용자_포인트_차감();
    	포인트_사용_내역_생성();
    }
    ```
    

- **주문 생성**
    
    ```tsx
    사용자_조회_TX () {
    	사용자_조회();
    }
    
    주문_생성_TX () {
    	주문_생성();
    	주문_디테일_생성();
    }
    
    상품_재고_감소_TX () {
    	상품_조회();
    	상품_재고_감소();
    }
    
    쿠폰_처리_TX () {
    	유저_쿠폰_조회();
    	쿠폰_상태_변경_및_가격_계산();
    }
    ```
    

## MSA에서의 트랜잭션 관리

---

### MSA의 특징

- 독립적 배포: 각 도메인은 독립적으로 배포되고 운영될 수 있다.
- 자율성: 각 도메인은 자체 데이터베이스를 가질 수 있으며, 이는 데이터 일관성 문제를 야기할 수 있다.
- 확장성: 특정 도메인만 확장할 수 있어 효율적이다.

### 트랜잭션 관리의 한계

- 분산 트랜잭션: MSA에서는 여러 서비스가 하나의 트랜잭션에 참여할 수 없으므로, 전통적인 ACID 트랜잭션을 유지하기가 어렵다.
- 데이터 일관성: 각 도메인이 독립적으로 운영되기 때문에 데이터 일관성을 유지하기 어렵다.
- 복잡성 증가: 트랜잭션 관리가 복잡해지고, 각 도메인 간 통신이 필요하다.

### 해결방안

- **2PC (Two-Phase Commit)**
    - 개념: 2PC는  분산 트랜잭션을 관리하기 위한 전통적인 방법이다. 두 단계로 나누어 트랜잭션을 커밋한다.
    - 동작 과정
        - **준비 단계 (Prepare Phase)**: 모든 참여 서비스가 트랜잭션을 준비하고, 준비 완료를 알립니다.
        - **커밋 단계 (Commit Phase)**: 모든 서비스가 준비 완료를 알리면, 트랜잭션을 커밋합니다. 하나라도 실패하면 롤백합니다.
    - 문제점
        - 2PC는 데이터 일관성을 보장하지만, 성능 저하와 복잡성 증가의 단점이 있습니다.
- **SAGA 패턴**
    1. 오케스트레이션 (Orchestration)
        - **중앙 조정자**가 모든 트랜잭션 단계를 관리합니다.
        - **중앙 조정자**가 각 서비스에 트랜잭션을 수행하도록 명령합니다.
            
            ```mermaid
            sequenceDiagram
                participant Orchestrator
                participant ServiceA
                participant ServiceB
                participant ServiceC
            
                Orchestrator->>ServiceA: Start Transaction
                ServiceA-->>Orchestrator: Success
                Orchestrator->>ServiceB: Start Transaction
                ServiceB-->>Orchestrator: Success
                Orchestrator->>ServiceC: Start Transaction
                ServiceC-->>Orchestrator: Success
            ```
            

1. 코레오그래피 (Choreography)
    - 각 서비스가 **이벤트**를 통해 트랜잭션을 수행합니다.
    - 서비스 간의 **이벤트 기반 통신**으로 트랜잭션을 관리합니다.
        
        ```mermaid
        sequenceDiagram
            participant ServiceA
            participant ServiceB
            participant ServiceC
        
            ServiceA->>ServiceB: Event A Completed
            ServiceB-->>ServiceA: Event B Completed
            ServiceB->>ServiceC: Event B Completed
            ServiceC-->>ServiceB: Event C Completed
        ```
        

SAGA 패턴에서의 트랜잭션은 Isolation을 보장하지 않기 때문에 이를 보완하기 위한 설계가 필요하다.

## 결론

---

- MSA로의 전환은 시스템의 확장성과 유연성을 크게 향상시킬 수 있지만, 트랜잭션 관리의 복잡성을 증가시킨다.
- 모놀리식 아키텍처에서는 ACID 특성을 쉽게 유지할 수 있지만, MSA에서는 분산된 환경에서 데이터의 일관성을 유지하는 것이 도전 과제가 된다.
- 이를 해결하기 위해 2PC와 SAGA 패턴과 같은 다양한 트랜잭션 관리 기법이 존재한다.
    - 2PC는 데이터 일관성을 보장하지만, 성능 저하와 복잡성 증가의 단점이 있다.
    - SAGA 패턴은 오케스트레이션과 코레오그래피 방식을 통해 분산 트랜잭션을 보다 유연하게 관리할 수 있다. 하지만,  트랜잭션의 Isolation을 보장하지 않기 때문에 이를 보완하기 위한 설계가 필요하다.
        - **오케스트레이션** 방식은 중앙 조정자를 통해 트랜잭션을 관리하여 명확한 흐름을 제공하지만, 단일 장애점이 될 수 있습니다.
        - **코레오그래피** 방식은 서비스 간의 이벤트 기반 통신을 통해 자율성을 높이고, 단일 장애점을 제거하지만, 복잡성이 증가할 수 있습니다.
- 적절한 패턴을 선택함으로써 MSA 환경에서 데이터 일관성을 유지하면서도 성능을 최적화할 수 있다.
- 결론적으로, MSA로의 전환은 신중한 설계와 적절한 트랜잭션 관리 전략을 필요로 한다. 각 도메인의 독립성을 유지하면서도 전체 시스템의 일관성을 보장하는 것이 중요하며, 이를 통해 MSA의 장점을 최대한 활용할 수 있다.
